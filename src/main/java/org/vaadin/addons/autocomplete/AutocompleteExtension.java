package org.vaadin.addons.autocomplete;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import org.vaadin.addons.autocomplete.client.AutocompleteExtensionClientRpc;
import org.vaadin.addons.autocomplete.client.AutocompleteExtensionServerRpc;
import org.vaadin.addons.autocomplete.client.AutocompleteExtensionState;
import org.vaadin.addons.autocomplete.client.SuggestionData;
import org.vaadin.addons.autocomplete.converter.SuggestionCaptionConverter;
import org.vaadin.addons.autocomplete.converter.SuggestionValueConverter;
import org.vaadin.addons.autocomplete.event.SuggestionSelectEvent;
import org.vaadin.addons.autocomplete.event.SuggestionSelectListener;
import org.vaadin.addons.autocomplete.generator.SuggestionGenerator;

import com.vaadin.data.provider.DataKeyMapper;
import com.vaadin.server.AbstractExtension;
import com.vaadin.server.KeyMapper;
import com.vaadin.shared.Registration;
import com.vaadin.ui.TextField;

/**
 * Extension for {@link TextField} for adding autocomplete functionality. As the
 * user types, suggestions appear under the text field component.
 * <p>
 * Suggestions are generated by a {@link SuggestionGenerator} and can be any
 * type. Suggestions are transferred to client as a list of caption-value pairs.
 * Caption is the visible HTML part. Value is to be set as text field value when
 * suggestion is selected. {@link SuggestionCaptionConverter} is responsible for
 * translating caption while {@link SuggestionValueConverter} translates the
 * value.
 *
 * @param <T>
 *         Type of the data to be generated. Can be the type of any Java
 *         object.
 * @see SuggestionGenerator
 * @see SuggestionCaptionConverter
 * @see SuggestionValueConverter
 */
public class AutocompleteExtension<T> extends AbstractExtension {

    private SuggestionGenerator<T> suggestionGenerator;
    private SuggestionCaptionConverter<T> captionConverter;
    private SuggestionValueConverter<T> valueConverter;

    private final SuggestionCaptionConverter<T> defaultCaptionConverter =
            (s, q) -> s.toString();
    private final SuggestionValueConverter<T> defaultValueConverter = T::toString;

    private final DataKeyMapper<T> keyMapper = new KeyMapper<>();
    private final Map<String, Set<String>> queryToKeyMap = new HashMap<>();

    /**
     * Extends {@code textField} to add autocomplete functionality.
     *
     * @param textField
     *         Field to be extended.
     */
    public AutocompleteExtension(TextField textField) {
        registerRpc(new AutocompleteExtensionServerRpc() {
            @Override
            public void getSuggestion(String query, String previousQuery) {
                Optional.ofNullable(suggestionGenerator).ifPresent(generator -> {
                    // Generate suggestion list
                    List<T> suggestions = generator
                            .apply(query, getState(false).suggestionListSize);

                    // Get converters
                    SuggestionCaptionConverter<T> cConverter = Optional
                            .ofNullable(captionConverter)
                            .orElse(defaultCaptionConverter);
                    SuggestionValueConverter<T> vConverter = Optional
                            .ofNullable(valueConverter)
                            .orElse(defaultValueConverter);

                    // Create a list of suggestion data and send it to the client
                    getRpcProxy(AutocompleteExtensionClientRpc.class)
                            .showSuggestions(Optional.ofNullable(suggestions)
                                    .orElse(Collections.emptyList()).stream()
                                    .map(s -> convertToSuggestionData(s,
                                            query, vConverter, cConverter))
                                    .collect(Collectors.toList()), query);
                });

                // Clear up the key mapper by removing references to old queries
                Predicate<Map.Entry<String, Set<String>>> activeQuery = entry ->
                        entry.getKey().equals(query) || entry.getKey()
                                .equals(previousQuery);
                Set<String> activeKeys = queryToKeyMap.entrySet().stream()
                        .filter(activeQuery)
                        .map(Map.Entry::getValue).flatMap(Set::stream)
                        .collect(Collectors.toSet());

                // Remove inactive keys
                queryToKeyMap.values().stream().flatMap(Set::stream)
                        .filter(k -> !activeKeys.contains(k))
                        .forEach(k -> keyMapper.remove(keyMapper.get(k)));
                queryToKeyMap.entrySet().removeIf(activeQuery.negate());
            }

            @Override
            public void suggestionSelected(String key, String value) {
                final T selectedItem = keyMapper.get(key);
                fireEvent(new SuggestionSelectEvent<>(textField, selectedItem,
                        value));
            }
        });

        super.extend(textField);
    }

    private SuggestionData convertToSuggestionData(T item, String query,
            SuggestionValueConverter<T> vConverter,
            SuggestionCaptionConverter<T> cConverter) {

        SuggestionData data = new SuggestionData(keyMapper.key(item),
                vConverter.apply(item), cConverter.apply(item, query));

        // Store query-key pairs in a map
        if (!queryToKeyMap.containsKey(query)) {
            queryToKeyMap.put(query, new HashSet<>());
        }
        queryToKeyMap.get(query).add(data.getKey());

        return data;
    }

    /**
     * Sets the suggestion generator for this extension. This generator is used
     * for creating suggestions when user types into the text field.
     *
     * @param suggestionGenerator
     *         Generator to be set.
     */
    public void setSuggestionGenerator(
            SuggestionGenerator<T> suggestionGenerator) {
        setSuggestionGenerator(suggestionGenerator, null, null);
    }

    /**
     * Sets the suggestion generator and converters for this extension.
     *
     * @param suggestionGenerator
     *         Generator for generating suggestions for user input.
     * @param valueConverter
     *         Converter to translate suggestion to value to be sat as text
     *         value when suggestion is selected.
     * @param captionConverter
     *         Converter to translate suggestion to safe HTML caption to be
     *         displayed for the user.
     */
    public void setSuggestionGenerator(
            SuggestionGenerator<T> suggestionGenerator,
            SuggestionValueConverter<T> valueConverter,
            SuggestionCaptionConverter<T> captionConverter) {
        this.suggestionGenerator = suggestionGenerator;
        this.valueConverter = valueConverter;
        this.captionConverter = captionConverter;
    }

    /**
     * Delay server callback for suggestions {@code delayMillis} milliseconds.
     *
     * @param delayMillis
     *         Delay in milliseconds. Must not be negative.
     */
    public void setSuggestionDelay(int delayMillis) {
        if (delayMillis < 0) {
            throw new IllegalArgumentException("Delay must be positive.");
        }

        if (!Objects.equals(getState(false).suggestionDelay, delayMillis)) {
            getState().suggestionDelay = delayMillis;
        }
    }

    /**
     * Returns delay for user input before server callback.
     *
     * @return Delay in milliseconds.
     */
    public int getSuggestionDelay() {
        return getState(false).suggestionDelay;
    }

    /**
     * Set maximum allowed size of the suggestion list.
     *
     * @param size
     *         Size of the suggestion list. Must not be negative.
     * @since 0.1.4
     */
    public void setSuggestionListSize(int size) {
        if (size < 0) {
            throw new IllegalArgumentException("Size must be positive");
        }

        if (!Objects.equals(getState(false).suggestionListSize, size)) {
            getState().suggestionListSize = size;
        }
    }

    /**
     * Returns the maximum allowed size of the suggestion list.
     *
     * @return Maximum allowed size of the suggestion list.
     * @since 0.1.4
     */
    public int getSuggestionListSize() {
        return getState(false).suggestionListSize;
    }

    /**
     * Triggers showing suggestions for the text field this extension extends.
     * Calling this method will start a server round trip containing the text
     * field's current value and will open the suggestion list with the
     * suggestions returned by the server.
     *
     * @since 0.2.2
     */
    public void showSuggestions() {
        getRpcProxy(AutocompleteExtensionClientRpc.class)
                .triggerShowSuggestions();
    }

    /**
     * Hides suggestion list for the text field extended by this extension.
     *
     * @since 0.2.2
     */
    public void hideSuggestions() {
        getRpcProxy(AutocompleteExtensionClientRpc.class)
                .triggerHideSuggestions();
    }

    /**
     * Add listener for suggestion select events. The event is triggered
     * whenever a suggestion item is selected by either mouse or keyboard.
     *
     * @param listener
     *         Listener for suggestion select events.
     * @return Handle for removing the listener.
     * @since 0.2.0
     */
    public Registration addSuggestionSelectListener(
            SuggestionSelectListener<T> listener) {
        return addListener(SuggestionSelectEvent.class, listener,
                SuggestionSelectListener.SUGGESTION_SELECT_METHOD);
    }

    @Override
    protected AutocompleteExtensionState getState() {
        return (AutocompleteExtensionState) super.getState();
    }

    @Override
    protected AutocompleteExtensionState getState(boolean markAsDirty) {
        return (AutocompleteExtensionState) super.getState(markAsDirty);
    }
}
